---
title: Python Quickstart
description: Build your first voice agent with Python
---

# Python Quickstart

Build a voice agent in Python using the official Vora SDK. This guide covers creating agents, managing sessions, and handling voice connections.

---

## Prerequisites

- Python 3.9 or later
- A Vora account with API key
- pip or poetry package manager

---

## Installation

<Tabs>
  <Tab title="pip">
    ```bash
    pip install vora-sdk livekit
    ```
  </Tab>
  <Tab title="poetry">
    ```bash
    poetry add vora-sdk livekit
    ```
  </Tab>
  <Tab title="uv">
    ```bash
    uv add vora-sdk livekit
    ```
  </Tab>
</Tabs>

---

## Step 1: Initialize the Client

Create a client instance with your API key:

```python
# vora_client.py
import os
from vora import VoraClient

client = VoraClient(
    api_key=os.environ.get("VORA_API_KEY")
)
```

<Warning>
  Store your API key in environment variables. Never commit secrets to version control.
</Warning>

---

## Step 2: Create an Agent

Define a voice agent with a system prompt:

```python
# create_agent.py
from vora_client import client

async def create_agent():
    agent = await client.agents.create(
        name="Customer Support Agent",
        system_prompt="""You are a friendly customer support agent for Acme Corp.

Your responsibilities:
- Answer questions about our products and services
- Help customers with their orders
- Provide a positive experience

Keep responses concise and conversational. Ask clarifying questions when needed.""",
        voice={
            "provider": "elevenlabs",
            "voice_id": "EXAVITQu4vr4xnSDxMaL"  # Sarah voice
        },
        model={
            "provider": "openai",
            "model": "gpt-4-turbo",
            "temperature": 0.7
        }
    )

    print(f"Agent created: {agent.id}")
    return agent

if __name__ == "__main__":
    import asyncio
    asyncio.run(create_agent())
```

---

## Step 3: Create a Voice Session

Generate a session for voice connection:

```python
# create_session.py
from vora_client import client

async def create_session(agent_id: str, user_id: str = "user_123"):
    session = await client.sessions.create(
        agent_id=agent_id,
        user_id=user_id,
        variables={
            "customer_name": "John",
            "account_type": "premium"
        }
    )

    print(f"Session created: {session.id}")
    print(f"Room URL: {session.room_url}")
    print(f"Token: {session.token}")

    return session
```

---

## Step 4: Connect to Voice

Use the LiveKit Python SDK to handle voice:

```python
# voice_client.py
import asyncio
from livekit import rtc

async def connect_to_voice(room_url: str, token: str):
    room = rtc.Room()

    # Event handlers
    @room.on("participant_connected")
    def on_participant_connected(participant):
        if participant.identity.startswith("agent_"):
            print("Agent joined the room")

    @room.on("track_subscribed")
    def on_track_subscribed(track, publication, participant):
        if track.kind == rtc.TrackKind.KIND_AUDIO:
            print(f"Audio track from {participant.identity}")
            # Handle audio playback

    @room.on("data_received")
    def on_data_received(data, participant):
        message = json.loads(data.decode())
        if message.get("type") == "transcript":
            speaker = message["speaker"]
            text = message["text"]
            print(f"{speaker}: {text}")

    # Connect to the room
    await room.connect(room_url, token)
    print("Connected to voice session")

    # Enable microphone
    source = rtc.AudioSource()
    track = rtc.LocalAudioTrack.create_audio_track("mic", source)
    await room.local_participant.publish_track(track)

    return room
```

---

## Step 5: Full Application

Here's a complete command-line voice agent:

```python
# main.py
import asyncio
import os
import json
from vora import VoraClient
from livekit import rtc

class VoiceAgent:
    def __init__(self):
        self.client = VoraClient(
            api_key=os.environ.get("VORA_API_KEY")
        )
        self.room = None
        self.agent_id = None

    async def setup_agent(self, name: str, system_prompt: str):
        """Create or retrieve an agent."""
        agent = await self.client.agents.create(
            name=name,
            system_prompt=system_prompt,
            voice={
                "provider": "elevenlabs",
                "voice_id": "EXAVITQu4vr4xnSDxMaL"
            }
        )
        self.agent_id = agent.id
        print(f"Agent ready: {agent.name}")
        return agent

    async def start_session(self, user_id: str = "user_123"):
        """Create a voice session and connect."""
        session = await self.client.sessions.create(
            agent_id=self.agent_id,
            user_id=user_id
        )

        self.room = rtc.Room()
        self._setup_event_handlers()

        await self.room.connect(session.room_url, session.token)
        print("Voice session started. Speak now!")

        return session

    def _setup_event_handlers(self):
        """Set up room event handlers."""
        @self.room.on("data_received")
        def on_data(data, participant):
            try:
                message = json.loads(data.decode())
                if message.get("type") == "transcript":
                    speaker = "Agent" if message["speaker"] == "agent" else "You"
                    print(f"\n{speaker}: {message['text']}")
            except json.JSONDecodeError:
                pass

        @self.room.on("disconnected")
        def on_disconnect():
            print("\nSession ended.")

    async def run(self):
        """Main loop to keep session alive."""
        try:
            while self.room and self.room.connection_state == rtc.ConnectionState.CONN_CONNECTED:
                await asyncio.sleep(1)
        except KeyboardInterrupt:
            print("\nEnding session...")
        finally:
            if self.room:
                await self.room.disconnect()

async def main():
    agent = VoiceAgent()

    # Create agent
    await agent.setup_agent(
        name="Support Bot",
        system_prompt="You are a helpful assistant. Be friendly and concise."
    )

    # Start voice session
    await agent.start_session()

    # Keep running
    await agent.run()

if __name__ == "__main__":
    asyncio.run(main())
```

---

## FastAPI Integration

Create a REST API for session management:

```python
# api.py
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from vora import VoraClient
import os

app = FastAPI()
client = VoraClient(api_key=os.environ.get("VORA_API_KEY"))

class SessionRequest(BaseModel):
    agent_id: str
    user_id: str | None = None
    variables: dict | None = None

class SessionResponse(BaseModel):
    session_id: str
    token: str
    room_url: str

@app.post("/api/sessions", response_model=SessionResponse)
async def create_session(request: SessionRequest):
    try:
        session = await client.sessions.create(
            agent_id=request.agent_id,
            user_id=request.user_id or "anonymous",
            variables=request.variables or {}
        )

        return SessionResponse(
            session_id=session.id,
            token=session.token,
            room_url=session.room_url
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/sessions/{session_id}")
async def get_session(session_id: str):
    try:
        session = await client.sessions.get(session_id)
        return {
            "id": session.id,
            "status": session.status,
            "duration": session.duration,
            "created_at": session.created_at.isoformat()
        }
    except Exception as e:
        raise HTTPException(status_code=404, detail="Session not found")

@app.get("/api/sessions/{session_id}/transcript")
async def get_transcript(session_id: str):
    try:
        transcript = await client.sessions.get_transcript(session_id)
        return {
            "session_id": session_id,
            "messages": transcript.messages,
            "word_count": transcript.word_count
        }
    except Exception as e:
        raise HTTPException(status_code=404, detail="Transcript not found")
```

Run with:

```bash
uvicorn api:app --reload
```

---

## Django Integration

Add Vora to a Django application:

```python
# views.py
from django.http import JsonResponse
from django.views import View
from django.conf import settings
from vora import VoraClient
import json

client = VoraClient(api_key=settings.VORA_API_KEY)

class CreateSessionView(View):
    async def post(self, request):
        try:
            data = json.loads(request.body)
            agent_id = data.get("agent_id")

            if not agent_id:
                return JsonResponse({"error": "agent_id required"}, status=400)

            session = await client.sessions.create(
                agent_id=agent_id,
                user_id=str(request.user.id) if request.user.is_authenticated else "anonymous",
                variables={
                    "username": request.user.username if request.user.is_authenticated else "Guest"
                }
            )

            return JsonResponse({
                "session_id": session.id,
                "token": session.token,
                "room_url": session.room_url
            })

        except Exception as e:
            return JsonResponse({"error": str(e)}, status=500)
```

---

## Error Handling

Implement robust error handling:

```python
from vora import VoraClient
from vora.exceptions import (
    VoraError,
    RateLimitError,
    AuthenticationError,
    NotFoundError
)
import asyncio

async def create_session_with_retry(client, agent_id, max_retries=3):
    for attempt in range(max_retries):
        try:
            return await client.sessions.create(agent_id=agent_id)

        except RateLimitError as e:
            if attempt < max_retries - 1:
                delay = e.retry_after or (2 ** attempt)
                print(f"Rate limited. Retrying in {delay}s...")
                await asyncio.sleep(delay)
            else:
                raise

        except AuthenticationError:
            raise ValueError("Invalid API key. Check your VORA_API_KEY.")

        except NotFoundError:
            raise ValueError(f"Agent {agent_id} not found.")

        except VoraError as e:
            print(f"Vora error: {e.message}")
            raise

    raise Exception("Max retries exceeded")
```

---

## Type Hints

The SDK includes comprehensive type hints:

```python
from vora import VoraClient
from vora.types import (
    Agent,
    Session,
    Transcript,
    VoiceConfig,
    ModelConfig
)

async def create_configured_agent(
    client: VoraClient,
    name: str,
    prompt: str,
    voice: VoiceConfig | None = None
) -> Agent:
    """Create an agent with optional voice configuration."""
    return await client.agents.create(
        name=name,
        system_prompt=prompt,
        voice=voice or {
            "provider": "elevenlabs",
            "voice_id": "EXAVITQu4vr4xnSDxMaL"
        }
    )

async def get_session_details(
    client: VoraClient,
    session_id: str
) -> tuple[Session, Transcript | None]:
    """Get session with optional transcript."""
    session = await client.sessions.get(session_id)
    transcript = None

    if session.status == "completed":
        transcript = await client.sessions.get_transcript(session_id)

    return session, transcript
```

---

## Next Steps

<CardGroup cols={2}>
  <Card title="SDK Reference" icon="book" href="/sdks/python">
    Complete Python SDK documentation
  </Card>
  <Card title="Add Functions" icon="function" href="/developers/concepts/functions">
    Enable agent actions
  </Card>
  <Card title="Knowledge Base" icon="database" href="/developers/concepts/knowledge-base">
    Add RAG for document retrieval
  </Card>
  <Card title="Webhooks" icon="webhook" href="/developers/webhooks">
    Receive session events
  </Card>
</CardGroup>

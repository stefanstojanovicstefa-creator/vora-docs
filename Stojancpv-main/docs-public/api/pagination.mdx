---
title: Pagination
description: How to paginate through large datasets in the Vora API
---

# Pagination

The Vora API uses cursor-based pagination for list endpoints. This approach provides consistent results even when data changes between requests.

## How It Works

When you request a list of resources, the response includes pagination metadata:

```json
{
  "data": [
    { "id": "agent_abc", "name": "Sales Agent" },
    { "id": "agent_def", "name": "Support Agent" }
  ],
  "pagination": {
    "has_more": true,
    "next_cursor": "eyJpZCI6ImFnZW50X2RlZiJ9",
    "prev_cursor": null,
    "total": 47
  }
}
```

| Field | Type | Description |
|-------|------|-------------|
| `has_more` | boolean | Whether more results exist |
| `next_cursor` | string | Cursor for the next page (null if no more) |
| `prev_cursor` | string | Cursor for the previous page (null if first page) |
| `total` | number | Total count of matching resources |

## Pagination Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `limit` | integer | 20 | Number of items per page (max: 100) |
| `cursor` | string | - | Cursor from previous response |
| `order` | string | `desc` | Sort order: `asc` or `desc` |
| `order_by` | string | `created_at` | Field to sort by |

## Basic Pagination

<CodeGroup>
```javascript JavaScript
// Fetch first page
const firstPage = await fetch('https://api.voicevora.com/v1/agents?limit=10', {
  headers: { 'Authorization': `Bearer ${apiKey}` }
}).then(r => r.json());

console.log(`Showing ${firstPage.data.length} of ${firstPage.pagination.total} agents`);

// Fetch next page
if (firstPage.pagination.has_more) {
  const nextPage = await fetch(
    `https://api.voicevora.com/v1/agents?limit=10&cursor=${firstPage.pagination.next_cursor}`,
    { headers: { 'Authorization': `Bearer ${apiKey}` } }
  ).then(r => r.json());
}
```

```python Python
import requests

# Fetch first page
response = requests.get(
    'https://api.voicevora.com/v1/agents',
    params={'limit': 10},
    headers={'Authorization': f'Bearer {api_key}'}
)
first_page = response.json()

print(f"Showing {len(first_page['data'])} of {first_page['pagination']['total']} agents")

# Fetch next page
if first_page['pagination']['has_more']:
    response = requests.get(
        'https://api.voicevora.com/v1/agents',
        params={
            'limit': 10,
            'cursor': first_page['pagination']['next_cursor']
        },
        headers={'Authorization': f'Bearer {api_key}'}
    )
    next_page = response.json()
```

```bash cURL
# First page
curl "https://api.voicevora.com/v1/agents?limit=10" \
  -H "Authorization: Bearer YOUR_API_KEY"

# Next page (use next_cursor from previous response)
curl "https://api.voicevora.com/v1/agents?limit=10&cursor=eyJpZCI6ImFnZW50X2RlZiJ9" \
  -H "Authorization: Bearer YOUR_API_KEY"
```
</CodeGroup>

## Iterating Through All Results

### Async Iterator Pattern (Recommended)

<CodeGroup>
```javascript JavaScript
async function* paginateAgents(options = {}) {
  const { limit = 20 } = options;
  let cursor = null;

  do {
    const params = new URLSearchParams({ limit: String(limit) });
    if (cursor) params.set('cursor', cursor);

    const response = await fetch(
      `https://api.voicevora.com/v1/agents?${params}`,
      { headers: { 'Authorization': `Bearer ${apiKey}` } }
    );

    const { data, pagination } = await response.json();

    for (const agent of data) {
      yield agent;
    }

    cursor = pagination.next_cursor;
  } while (cursor);
}

// Usage
for await (const agent of paginateAgents({ limit: 50 })) {
  console.log(`Processing: ${agent.name}`);
}
```

```python Python
from typing import Generator, Dict, Any
import requests

def paginate_agents(limit: int = 20) -> Generator[Dict[str, Any], None, None]:
    cursor = None

    while True:
        params = {'limit': limit}
        if cursor:
            params['cursor'] = cursor

        response = requests.get(
            'https://api.voicevora.com/v1/agents',
            params=params,
            headers={'Authorization': f'Bearer {api_key}'}
        )
        result = response.json()

        for agent in result['data']:
            yield agent

        cursor = result['pagination'].get('next_cursor')
        if not cursor:
            break

# Usage
for agent in paginate_agents(limit=50):
    print(f"Processing: {agent['name']}")
```

```typescript TypeScript
interface Agent {
  id: string;
  name: string;
  // ... other fields
}

interface PaginatedResponse<T> {
  data: T[];
  pagination: {
    has_more: boolean;
    next_cursor: string | null;
    total: number;
  };
}

async function* paginateAgents(options: { limit?: number } = {}): AsyncGenerator<Agent> {
  const { limit = 20 } = options;
  let cursor: string | null = null;

  do {
    const params = new URLSearchParams({ limit: String(limit) });
    if (cursor) params.set('cursor', cursor);

    const response = await fetch(
      `https://api.voicevora.com/v1/agents?${params}`,
      { headers: { 'Authorization': `Bearer ${apiKey}` } }
    );

    const { data, pagination }: PaginatedResponse<Agent> = await response.json();

    for (const agent of data) {
      yield agent;
    }

    cursor = pagination.next_cursor;
  } while (cursor);
}

// Usage
for await (const agent of paginateAgents({ limit: 50 })) {
  console.log(`Processing: ${agent.name}`);
}
```
</CodeGroup>

### Collect All Results

When you need all results in an array:

<CodeGroup>
```javascript JavaScript
async function fetchAllAgents() {
  const agents = [];

  for await (const agent of paginateAgents({ limit: 100 })) {
    agents.push(agent);
  }

  return agents;
}

const allAgents = await fetchAllAgents();
console.log(`Fetched ${allAgents.length} agents total`);
```

```python Python
def fetch_all_agents() -> list:
    return list(paginate_agents(limit=100))

all_agents = fetch_all_agents()
print(f"Fetched {len(all_agents)} agents total")
```
</CodeGroup>

## Sorting Results

Control the order of results with `order` and `order_by` parameters:

```bash
# Most recent first (default)
curl "https://api.voicevora.com/v1/agents?order=desc&order_by=created_at"

# Oldest first
curl "https://api.voicevora.com/v1/agents?order=asc&order_by=created_at"

# Alphabetically by name
curl "https://api.voicevora.com/v1/agents?order=asc&order_by=name"
```

### Available Sort Fields

| Endpoint | Sortable Fields |
|----------|-----------------|
| `/agents` | `created_at`, `updated_at`, `name` |
| `/sessions` | `created_at`, `ended_at`, `duration` |
| `/knowledge-base` | `created_at`, `updated_at`, `name` |
| `/knowledge-base/:id/documents` | `created_at`, `name`, `size` |

## Filtering with Pagination

Combine filters with pagination for precise queries:

```javascript
// Fetch active agents, sorted by most recent calls
const response = await fetch(
  'https://api.voicevora.com/v1/agents?' + new URLSearchParams({
    limit: '20',
    status: 'deployed',
    order: 'desc',
    order_by: 'last_call_at'
  }),
  { headers: { 'Authorization': `Bearer ${apiKey}` } }
);
```

Common filter parameters (endpoint-specific):

| Endpoint | Filters |
|----------|---------|
| `/agents` | `status`, `created_after`, `created_before` |
| `/sessions` | `agent_id`, `status`, `started_after`, `started_before` |
| `/knowledge-base/:id/documents` | `type`, `status` |

## Best Practices

### 1. Use Reasonable Page Sizes

```javascript
// ❌ Too small - many API calls
const response = await fetch('/agents?limit=5');

// ❌ Too large - slow responses, timeout risk
const response = await fetch('/agents?limit=1000');

// ✅ Balanced - efficient and reliable
const response = await fetch('/agents?limit=50');
```

<Info>
  The optimal page size depends on your use case. For real-time UIs, use smaller pages (10-20). For batch processing, use larger pages (50-100).
</Info>

### 2. Don't Assume Cursor Stability

Cursors should be treated as opaque strings. Don't:
- Parse or decode cursors
- Store cursors long-term
- Share cursors between users

```javascript
// ❌ Don't do this
const cursor = 'eyJpZCI6ImFnZW50X2RlZiJ9';
const decoded = JSON.parse(atob(cursor)); // Don't decode!

// ✅ Just pass it as-is
const nextPage = await fetch(`/agents?cursor=${cursor}`);
```

### 3. Handle Empty Results Gracefully

```javascript
const { data, pagination } = await response.json();

if (data.length === 0 && !pagination.prev_cursor) {
  // No results at all
  showEmptyState();
} else if (data.length === 0) {
  // Reached end of results
  showEndOfResults();
} else {
  // Normal results
  displayResults(data);
}
```

### 4. Show Loading States Between Pages

```javascript
function LoadingIndicator() {
  return <div>Loading more results...</div>;
}

function AgentList() {
  const [agents, setAgents] = useState([]);
  const [loading, setLoading] = useState(false);
  const [cursor, setCursor] = useState(null);

  async function loadMore() {
    setLoading(true);
    const response = await fetchAgents(cursor);
    setAgents(prev => [...prev, ...response.data]);
    setCursor(response.pagination.next_cursor);
    setLoading(false);
  }

  return (
    <>
      {agents.map(agent => <AgentCard key={agent.id} agent={agent} />)}
      {loading && <LoadingIndicator />}
      {cursor && !loading && (
        <button onClick={loadMore}>Load More</button>
      )}
    </>
  );
}
```

### 5. Implement Infinite Scroll

```javascript
import { useInfiniteQuery } from '@tanstack/react-query';

function useAgents() {
  return useInfiniteQuery({
    queryKey: ['agents'],
    queryFn: async ({ pageParam }) => {
      const params = new URLSearchParams({ limit: '20' });
      if (pageParam) params.set('cursor', pageParam);

      const response = await fetch(`/api/agents?${params}`);
      return response.json();
    },
    getNextPageParam: (lastPage) => lastPage.pagination.next_cursor,
    initialPageParam: undefined
  });
}

function AgentList() {
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage
  } = useAgents();

  // Use IntersectionObserver or scroll handler to call fetchNextPage
}
```

## Error Handling

### Invalid Cursor

If a cursor becomes invalid (data changed significantly), you'll receive an error:

```json
{
  "error": {
    "code": "INVALID_CURSOR",
    "message": "The provided cursor is no longer valid",
    "details": {
      "hint": "Start from the beginning without a cursor"
    }
  }
}
```

Handle by restarting pagination:

```javascript
try {
  const response = await fetch(`/agents?cursor=${cursor}`);
  const data = await response.json();

  if (data.error?.code === 'INVALID_CURSOR') {
    // Restart from beginning
    cursor = null;
    return fetchAgents();
  }

  return data;
} catch (error) {
  handleError(error);
}
```

<CardGroup cols={2}>
  <Card title="Rate Limits" icon="gauge-high" href="/api/rate-limits">
    Stay within rate limits while paginating
  </Card>
  <Card title="Agents API" icon="robot" href="/api/agents">
    Paginate through your agents
  </Card>
</CardGroup>
